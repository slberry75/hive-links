===> ./index.html <==
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hive Links - Hex Grid</title>
    <link rel="stylesheet" href="styles.css">
    <script src="./scripts/script.js" type="module" defer></script>
</head>
<body>
    <h1>üêù Hive Links</h1>
    
    <div class="instructions">
        <strong>Goal:</strong> Fill the hexagonal grid with colors so that:
        <ul>
            <li>Numbers show how many neighbors share the same color</li>
            <li>All cells of each color form one connected group</li>
            <li>No single cell is completely surrounded by the opposite color</li>
        </ul>
    </div>
    
    <div id="game-container">
        <div class="controls">
            <div class="split-button">
                <button onclick="game.toggleMode()" id="mode-button">Paint</button>
                <select id="color-select" onchange="game.setSelectedColor(this.value)">
                    <option value="light">Light</option>
                    <option value="dark">Dark</option>
                </select>
            </div>
            <button onclick="game.newGame()">New Game</button>
            <button onclick="game.checkSolution()">Check Solution</button>
            <button onclick="game.reset()">Reset</button>
        </div>
        
        <div id="hex-grid"></div>
        
        <div id="status">Click hexagons to change their color!</div>
    </div>

</body>
</html>----------------------------------------

===> ./package.json <==
{
  "name": "hive-links",
  "version": "1.0.0",
  "main": "script.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "vite",
    "build": "vite build", 
    "preview": "vite preview" 
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "devDependencies": {
    "typescript": "^5.9.2",
    "vite": "^7.1.1"
  }
}
----------------------------------------

===> ./scripts/game-instance.ts <==
import { GameRenderer } from "./game-renderer";
import { GridContainer } from "./grid-container";
import { AxialCoordinates, HexLinkPuzzle, PuzzleGridCell } from "./puzzle-generator";

export class GameInstance {
    // properties
    readonly colors:PuzzleColorOptions;
    readonly difficulty: PuzzleDifficulty;
    readonly rings: number;
    readonly container: GridContainer;
    readonly cells?: Record<string, GameCell>;
    debugLayout: boolean;

    // computed properties:
    get cellSize(): ElementDimensions {
        const w = Math.floor(this.container.width / (this.rings * 2 + 1));
        const h = Math.sqrt(3)*w*.5; 
        return {width: w, height: h};
    }

    constructor(puzzle:HexLinkPuzzle, container:GridContainer, debugLayout:boolean = false) {
        this.colors = puzzle.colors;
        this.difficulty = puzzle.difficulty;
        this.rings = puzzle.rings;
        this.container = container;
        this.debugLayout = debugLayout;
        this.cells = Object.fromEntries(
            Object.entries(puzzle.cells as object).map(([key, value]) => [key, new GameCell(value.axialCoordinates)])
        );

        GameRenderer.render(this);
    }

}

export class GameCell extends PuzzleGridCell {
    readonly userColor:HexLinkColor|null = null;
    readonly userGuess:HexLinkColor|null = null;

    constructor(axialCoords:AxialCoordinates) {
        super(axialCoords);
    }

    scaleCoordinates(instance: GameInstance):NormalizedPixelLocation  {
        
        return Object.fromEntries(
            Object.entries(this.coordinates).map(([key, value]) => {
                const thisDimension =  key === 'x' ? instance.cellSize.width : instance.cellSize.height;
                const thisOrigin = key === 'x' ? instance.container.origin.x : instance.container.origin.y;
                return [key, (value*thisDimension*.6) + thisOrigin - (thisDimension / 2)]
            })
        ) as NormalizedPixelLocation
    }
}----------------------------------------

===> ./scripts/game-renderer.ts <==
import { GameCell, GameInstance } from "./game-instance";

export class GameRenderer {

    static render(instance:GameInstance):void {
        instance.container.ringContainer = null; 
        
        if (instance.debugLayout) {
            this.renderLayoutDebug(instance);
        }
        if (instance.cells) {
            Object.values(instance.cells)
                // .filter(cell => cell.axialCoordinates.toString() === '[0,0,0]')
                .forEach(cell => {
                    const realCoords = cell.scaleCoordinates(instance);
                    const el = document.createElement('div');
                    el.dataset.axialCoordinates = cell.axialCoordinates.toString();
                    el.className = 'hex-cell-container';
                    el.style.width = `${instance.cellSize.width}px`;
                    el.style.height = `${instance.cellSize.height}px`;
                    el.style.top = `${realCoords.y}px`
                    el.style.left = `${realCoords.x}px`
                    el.appendChild(this.getCellHexagon(cell));
                    instance.container.cellContainers?.push(el);
                    instance.container.element.appendChild(el)
                }
            )
        }
    }

    static getCellHexagon(cell:GameCell):SVGSVGElement {
        var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("class", "game-cell");
        svg.setAttribute('viewBox', '0 0 1 .866');
        // svg.setAttribute('viewBox', '-1 -1 2 2');
        svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
        
        var path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute('d', 'M 0, .433 L .25, .866 L .75, .866 L 1, .433 L .75, 0 L .25, 0 Z');
        path.setAttribute('fill', 'currentColor');
        svg.appendChild(path);
        return svg;
    }

    private static renderLayoutDebug(instance:GameInstance):void {
        const ringPercent = 100 / instance.rings;
        const ringContainer = document.createElement("div");
        ringContainer.className = "ring-container";
        ringContainer.style.margin = `${instance.cellSize.height/2}px ${instance.cellSize.width/2}px`;
        ringContainer.style.width = `calc(100%-${instance.cellSize.width}px)`;
        ringContainer.style.height = `calc(100%-${instance.cellSize.height}px)`;

        instance.container.ringContainer = ringContainer;

        for(let i = 1; i <= instance.rings; i++) {
            const thisRingSize = ringPercent*i
            const ring = document.createElement("div");
            ring.className = "grid-ring";
            ring.style.width = `${thisRingSize}%`;
            ringContainer.appendChild(ring);
        }

        instance.container.element.appendChild(ringContainer);
    }

}----------------------------------------

===> ./scripts/grid-container.ts <==
import { GameInstance } from "./game-instance";

export class GridContainer {

    // properties
    instance?: GameInstance
    element:HTMLElement
    ringContainer: HTMLElement|null = null;
    cellContainers: HTMLElement[]|null = null;
    
    // computed properties
    get width():number {
        return this.element.getBoundingClientRect().width;
    }
    get height():number {
        return this.element.getBoundingClientRect().height;
    }

    get origin():NormalizedPixelLocation {
        return {x: this.width/2, y: this.height/2};//this.height/2;
    }

    constructor(element:HTMLElement) {
        this.element = element;
    }

} ----------------------------------------

===> ./scripts/puzzle-generator.ts <==
const AxialOffsets =  [
    [1, 0, -1], // Right        
    [1, -1, 0], // Top Right  
    [0, -1, 1], // Top Left
    [-1, 0, 1], // Left   
    [-1, 1, 0], // Bottom Left
    [0, 1, -1]  // Bottom Right
];

export class HexLinkPuzzle {
    colors: PuzzleColorOptions;
    difficulty: PuzzleDifficulty;
    rings: number;
    initialized: boolean = false;
    cells?: Record<string, PuzzleGridCell> = undefined;

    constructor(colors:PuzzleColorOptions, difficulty:PuzzleDifficulty, rings:number) {
        this.colors = colors;
        this.difficulty = difficulty;
        this.rings = rings;
        this.cells = this.initCells();
    }

    private initCells  = (axialCoordinates?:AxialCoordinates, cells: Record<string, PuzzleGridCell> = {}) : Record<string, PuzzleGridCell> => {
        axialCoordinates??=new AxialCoordinates([0,0,0]);

        if (!this.largeEnoughForCoords(axialCoordinates)) {
            throw new Error(`Cell with coordinates ${axialCoordinates.toString()} out of bounds.  Limit is +/- ${this.rings}.`);
        }

        let thisCell = new PuzzleGridCell(axialCoordinates);
        cells[thisCell.axialCoordinates.toString()]  = thisCell;

        thisCell.neighbors
            .filter(x => this.largeEnoughForCoords(x) && !(x.toString() in cells))
            .forEach(x => {
                const cellsFromNeighbor = this.initCells(x, cells);
                Object.assign(cells, cellsFromNeighbor);
            })

        return cells;
    }

    private largeEnoughForCoords(coords: AxialCoordinates): boolean {
        return Math.max(Math.abs(coords.q), Math.abs(coords.r), Math.abs(coords.s)) <= this.rings
    }
}

export class PuzzleGridCell {
    // properties
    axialCoordinates: AxialCoordinates;
    solvedColor?: HexLinkColor ;  
    clue?: PuzzleClue
    barredNeighbors?:AxialCoordinates[];

    // computed properties
    get q(): number {
        return this.axialCoordinates.q;
    }
    get r(): number {
        return this.axialCoordinates.r;
    }
    get s(): number {
        return this.axialCoordinates.s;
    }

    get coordinates(): NormalizedPixelLocation {
        return {
            x:(3/2) * this.q,
            y:(Math.sqrt(3)/2 * this.q + Math.sqrt(3) * this.r)
        };
    }

    get neighbors():AxialCoordinates[] {
      return AxialOffsets.map(offset => {
        return { q: offset[0], r: offset[1], s: offset[2]};
      }).map(offset => new AxialCoordinates([this.q + offset.q, this.r + offset.r, this.s + offset.s]));  
    }

    //constructor
    constructor(axialCoords:AxialCoordinates, solvedColor=undefined, clue=undefined, barredNeighbors=undefined) {
        this.axialCoordinates = axialCoords;
        this.clue = clue;
        this.solvedColor = solvedColor;
        this.barredNeighbors = barredNeighbors;
    }
}

export class AxialCoordinates {
    // properties
    readonly q: number;
    readonly r: number;
    readonly s: number;

    constructor(coords:[number,number,number]);
    constructor(q:number,r:number,s:number);
    constructor(qOrCoords:[number,number,number]|number, r?: number, s?: number) {
        if (Array.isArray(qOrCoords)) 
        {
            r = qOrCoords[1];
            s = qOrCoords[2];
            qOrCoords = qOrCoords[0];
        }
          
        if (r === undefined || s === undefined)  
        {
            throw new Error("Invalid instantiation of Axial Coordinates");
        }
        else if (Math.abs(qOrCoords + r + s) > 0.0001)
        {
            throw new Error(`Invalid axial coordinates: ${[qOrCoords, r, s]}`);
        }
        else
        {
            this.q = qOrCoords;
            this.r = r;
            this.s = s;   
        }
    }

    toArray():[number,number,number] {
        return [this.q, this.r, this.s]
    }

    toString():string {
        return JSON.stringify(this.toArray());
    }
}----------------------------------------

===> ./scripts/script.ts <==
import { GameInstance } from "./game-instance";
import { GridContainer } from "./grid-container";
import { GameRenderer } from "./game-renderer";
import { HexLinkPuzzle } from "./puzzle-generator";

function getTestPuzzle(): HexLinkPuzzle {
    
    return new HexLinkPuzzle(
        [
            [93,0,255],
            [255,166,0],
            [255,0,153]
        ], 'easy',
        2
    );
}

const gridContainer =  document.getElementById('hex-grid');

if (gridContainer) {
    const container = new GridContainer(gridContainer);
    container.instance = new GameInstance(getTestPuzzle(), container, true);
    window.addEventListener('resize', () => {
        if (container.instance) {
            GameRenderer.render(container.instance);
        }
    });
}
----------------------------------------

===> ./scripts/types.ts <==
type PuzzleDifficulty = "easy" | "medium" | "hard";

type HexLinkColor = [number, number, number]

type PuzzleColorOptions = [HexLinkColor, HexLinkColor, ...HexLinkColor[]];

type NormalizedPixelLocation = {
    x: number;
    y: number;
}

type ElementDimensions = {
    width: number;
    height: number;
}
type PuzzleClue = {
    color?: HexLinkColor;
    matches?: number;
}----------------------------------------

===> ./styles.css <==
/* Basic page styling */
body {
    margin: 0;
    padding: 20px;
    font-family: Arial, sans-serif;
    background-color: #f0f0f0;
    display: flex;
    flex-direction: column;
    align-items: center;
}

h1 {
    color: #333;
    margin-bottom: 20px;
}

#game-container {
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    text-align: center;
}

.instructions {
    max-width: 500px;
    margin: 20px 0;
    padding: 15px;
    background: #e3f2fd;
    border-radius: 5px;
    text-align: left;
    display: none;
}

.controls {
    margin-bottom: 20px;
}

button {
    padding: 10px 20px;
    margin: 5px;
    border: none;
    border-radius: 5px;
    background: #2196F3;
    color: white;
    cursor: pointer;
    font-size: 16px;
}

button:hover {
    background: #1976D2;
}

/* Hex grid container */
#hex-grid {
    position: relative;
    max-width: 800px;
    max-height: 800px;
    aspect-ratio: 1 / 1; /* Adjusted for hexagonal grid */
    margin: 20px auto;
    background: #fafafa;
    border: 2px solid #ddd;
    border-radius: 10px;
    box-sizing: border-box;
}

#hex-grid .hex-cell-container {
    position: absolute;
    border: 1px solid #333;
    padding: 2px;
    box-sizing: border-box; /* Ensures padding and border are included in width/height */
}

#hex-grid .hex-cell-container .game-cell {
    width: 100%;
    height: 100%;
    color: rgb(210, 201, 160);
    box-sizing: border-box;
}

/*** Developoment Styles (only for development mode **/

.ring-container {
    position:absolute;
    top: 0;
    left: 0;
    bottom: 0;  
    right: 0;
}

.ring-container .grid-ring {
    position: absolute;
    margin: auto;
    top: 0;
    left: 0;  
    bottom: 0;
    right: 0;
    border-radius: 50%;
    border: 1px solid rgba(118, 164, 228, 1);
    aspect-ratio: 1 / 1; /* Ensures circular shape */
}


.test-colors {
    color: rgb(93, 0, 255);
    color: rgb(255, 166, 0);
    color: rgb(255, 0, 153);
}----------------------------------------

